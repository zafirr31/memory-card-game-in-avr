

; Pembuat:
; Zafir Rasyidi Taufik
; Ariell Zaky Prabaswara Ariza
; Aljihad Ijlal Nadhif Suyudi

.include "m8515def.inc"
.def arg1 = r1	; function arguments
.def arg2 = r2  ; function arguments
.def SEED = r3
.def DELAYREG1 = r8
.def DELAYREG2 = r9
.def LEVELTIME = r5
.def LOKASICURSOR = r6
.def temp = r16
.def LEVELCOUNTER = r19
.def LEVELTIMENOW = r20

.org $00
	rjmp INIT

.org $04
	; 1 DETIK TELAH BERLALU
	rjmp ADD_LEVEL_TIME_NOW

INIT:
	ldi	temp, low(RAMEND)
	out	SPL, temp				; init Stack Pointer
	ldi	temp, high(RAMEND)
	out	SPH, temp				; init Stack Pointer

	INIT_LCD:
		cbi PORTA,1 ; CLR RS
		ldi temp,0x38 ; MOV DATA,0x38 --> 8bit, 2line, 5x7
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		cbi PORTA,1 ; CLR RS
		ldi temp,$0E ; MOV DATA,0x0E --> disp ON, cursor ON, blink OFF
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		rcall CLEAR_LCD ; CLEAR LCD
		cbi PORTA,1 ; CLR RS
		ldi temp,$06 ; MOV DATA,0x06 --> increase cursor, display sroll OFF
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		ser temp
		out DDRA,temp ; Set port A as output
		out DDRB,temp ; Set port B as output

	; SETUP LED HERE
	; Mungkin tidak pake

	; SETUP TIMER HERE
		; TIMER 1 UNTUK WAKTU PER LEVEL
	INIT_TIMER:
		ldi temp, 1<<CS11			; prescalar 256
		out TCCR1B, temp
		ldi temp, 1<<OCF1A			; interrupt if compare true in T/C1B
		out TIFR, temp	
		ldi temp, 1<<OCIE1A			; Enable timer/counter1B compare int
		out TIMSK, temp
		ldi temp, $F4				
		out OCR1AH, temp
		ldi temp, $24				; Compared value, to be around 1 second
		out OCR1AL, temp
		sei

		; TIMER 0 UNTUK RANDOM GENERATOR
	ldi temp, 1<<CS00			; No prescalar, turn it on
	out TCCR0,temp

	; SETUP KEYPAD HERE


	rcall main

	; RESET

DELAY:
	; Generated by delay loop calculator
	; at http://www.bretmulvey.com/avrdelay.html
	;
	; DELAY_CONTROL 40 000 cycles
	; 5ms at 8.0 MHz

	    ldi  temp, 52
	    mov DELAYREG1, temp
	    ldi  temp, 242
	    mov DELAYREG2, temp	    
	L1: dec  DELAYREG2
	    brne L1
	    dec  DELAYREG1
	    brne L1
	    nop
	ret

PUT_STRING:
	mov ZL,arg1 ; Load low part of byte address into ZL
	mov ZH,arg2 ; Load high part of byte address into ZH
	
	LOADBYTE:
		lpm ; Load byte from program memory into r0

		tst r0 ; Check if we've reached the end of the message
		breq END_LCD ; If so, quit

		mov arg1, r0
		rcall WRITE_TEXT
		adiw ZL,1 ; Increase Z registers
		rjmp LOADBYTE

	END_LCD:
		ret

WRITE_TEXT:
	mov temp, arg1 ; Put the character onto Port B
	sbi PORTA,1 ; SETB RS
	out PORTB, temp
	sbi PORTA,0 ; SETB EN
	cbi PORTA,0 ; CLR EN
	rcall DELAY
	ret

CLEAR_LCD:
	cbi PORTA,1 ; CLR RS
	ldi temp,$01 ; MOV DATA,0x01
	out PORTB,temp
	sbi PORTA,0 ; SETB EN
	cbi PORTA,0 ; CLR EN
	rcall DELAY
	ret

RESER_TIMER0:
	clr temp
	out TCNT0, temp
	ret

RESET_TIMER1:
	clr temp
	out TCNT1H, temp
	out TCNT1L, temp
	ret

ADD_LEVEL_TIME_NOW:

	push temp
	in temp,SREG
	push temp

	rcall RESET_TIMER1
	
	; add 1 to timer
	inc LEVELTIMENOW

	pop temp
	out SREG,temp
	pop temp

	reti

GET_NAME:

	; USE KEYPAD TO INPUT NAME

	; GET VALUE IN TCNT0
	; USE VALUE AS SEED FOR RANDOM
	get_seed:
		in temp, TCNT0		; get value in timer for seed
		tst temp
		breq get_seed		; prevent seed=0
	mov SEED, temp

	ret

GET_RANDOM_NUMBER:

	; USING SEED, GENERATE NEXT RANDOM NUMBER
	; USE XORSHIFT ALGORITHM, https://en.wikipedia.org/wiki/Xorshift

	mov temp, SEED		; shift left by 2
	lsl temp
	lsl temp
	eor SEED, temp
	mov temp, SEED
	lsr temp			; shift right by 5
	lsr temp
	lsr temp
	lsr temp
	lsr temp
	eor SEED, temp
	mov temp, SEED
	lsl temp			; shift left by 3
	lsl temp
	lsl temp
	eor SEED, temp

	mov temp, SEED		; PUT VALUE IN temp


SETUP_LAYOUT:
	
	; EMPTY ENTIRE LAYOUT
	; USING RANDOM GENERATOR, SETUP LAYOUT
	; GET RANDOM VALUE, AND IMMEDIATE 31
	; CEK THAT LOCATION, IF ALREADY HAS NUMBER, ADD 1, AND IMMEDIATE 31
	; REPEAT 32 TIMES

MOVE_CURSOR:
	
	CEK_BISA:

		; LOKASICURSOR DALAM BATAS 0 - 31 (inklusif) ? BISA : TIDAK BISA

	; KIRI, BISA ? LOKASICURSOR -1
	; KANAN, BISA ? LOKASICURSOR +1
	; ATAS, BISA ? LOKASICURSOR -16
	; BAWAH, BISA ? LOKASICURSOR +16

OPEN_CARD:

	; DAPAT DIBUKA ? BUKA, COUNTER KARTU YANG TERBUKA +1 : RETURN DARI FUNGSI
	; YANG DIBUKA SUDAH 2 ? CEK KALO SAMA, COUNTER +1, BUKA SELAMANYA : TUTUP KEDUANYA

CLOSE_CARD:

	; GANTI SPRITE JADI BLACK BOX
	; COUNTER KARTU YANG TERBUKA -1

MAIN:
	
	; INPUT NAME FUNC, GET_NAME
	;;; rcall GET_NAME

	; SAVE NAME IN FLASH MEMORY
	; NAME HAS MAX OF 8 BYTES

	; DELAY, GET READY TO START GAME
	; PREPARE LAYOUT
	; PREPARE TIMER

	; LAYOUT DISIMPAN DI SRAM
	; COUNTER UNTUK KETAHUI JIKA PASANGAN TELAH DITEMUKAN
	; COUNTER == 16 ? UDAH SELESAI
	; LEVELTIMENOW == LEVELTIME ? KALAH
	; TAMBAHKAN 1 KE GLOBAL LEVEL COUNTER
	; START NEXT LEVEL, LEVELTIME -1

	; JIKA HABIS WAKTU, GAME BERAKHIR
	; SCORE > HIGHSCORE ? HIGHSCORE = SCORE
	; TAMPILKAN NAMA DAN HIGHSCORE

	; ADA BUTTON UNTUK MAIN ULANG
	; DITEKAN ? DELAY, RJMP INIT

	ldi temp, high(2*message_start)
	mov arg2, temp
	ldi temp, low(2*message_start)
	mov arg1, temp
	rcall PUT_STRING

	forever:
		rjmp forever

message_start:
.db "SIAP SIAP...", 0

message_habis_waktu:
.db "WAKTU HABIS!", 0

message_level_selesai:
.db "MANTAP!", 0

nama:
.db 0, 0, 0, 0, 0, 0, 0, 0, 0

highscore:
.db 0