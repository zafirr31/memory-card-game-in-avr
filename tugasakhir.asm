

; Pembuat:
; Zafir Rasyidi Taufik
; Ariell Zaky Prabaswara Ariza
; Aljihad Ijlal Nadhif Suyudi

; Kolaborator (Random Algorithm):
; Sean Zeliq Urian
; Adrian Wijaya
; Falih Mufazan

.include "m8515def.inc"
.def arg1 = r1	; function arguments
.def arg2 = r2  ; function arguments
.def arg3 = r3	; function arguments
.def SEED = r4
.def DELAYREG1 = r8
.def DELAYREG2 = r9
.def row = r10	; register pointing row
.def col = r11	; register pointing column
.def LEVELTIME = r5
.def lokasicursor = r6
.def temp = r16
.def temp2 = r17
.def LEVELCOUNTER = r19
.def LEVELTIMENOW = r20

.equ layout_address = 0x60

.org $00
	rjmp INIT

.org $04
	; 1 DETIK TELAH BERLALU
	rjmp ADD_LEVEL_TIME_NOW

INIT:
	ldi	temp, low(RAMEND)
	out	SPL, temp				; init Stack Pointer
	ldi	temp, high(RAMEND)
	out	SPH, temp				; init Stack Pointer

	INIT_LCD:
		cbi PORTA,1 ; CLR RS
		ldi temp,0x38 ; MOV DATA,0x38 --> 8bit, 2line, 5x7
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		cbi PORTA,1 ; CLR RS
		ldi temp,$0D ; MOV DATA,0x0D --> disp ON, cursor OFF, blink ON
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		rcall CLEAR_LCD ; CLEAR LCD
		cbi PORTA,1 ; CLR RS
		ldi temp,$06 ; MOV DATA,0x06 --> increase cursor, display sroll OFF
		out PORTB,temp
		sbi PORTA,0 ; SETB EN
		cbi PORTA,0 ; CLR EN
		rcall DELAY
		ser temp
		out DDRA,temp ; Set port A as output
		out DDRB,temp ; Set port B as output
		ldi temp, 0b10000000
		mov lokasicursor, temp

	; SETUP LED HERE
	; Mungkin tidak pake

	; SETUP TIMER HERE
		; TIMER 1 UNTUK WAKTU PER LEVEL
	INIT_TIMER_1:
		ldi temp, 1<<CS11			; prescalar 256
		out TCCR1B, temp
		ldi temp, 1<<OCF1A			; interrupt if compare true in T/C1B
		out TIFR, temp	
		ldi temp, 1<<OCIE1A			; Enable timer/counter1B compare int
		out TIMSK, temp
		ldi temp, $F4				
		out OCR1AH, temp
		ldi temp, $24				; Compared value, to be around 1 second
		out OCR1AL, temp
		sei

		; TIMER 0 UNTUK RANDOM GENERATOR
	INIT_TIMER_0:	
		ldi temp, 1<<CS00			; No prescalar, turn it on
		out TCCR0,temp

	; SETUP KEYPAD HERE
	INIT_KEYPAD:
		ldi temp,0b11110000 ; data direction register column lines output
		out DDRC,temp    ; set direction register
		ldi temp,0b00001111 ; Pull-Up-Resistors to lower four port pins
		out PORTC,temp    ; to output port

	rcall MAIN

	; RESET

DELAY:
	; Generated by delay loop calculator
	; at http://www.bretmulvey.com/avrdelay.html
	;
	; Delay 20 000 cycles
	; 5ms at 4.0 MHz

	    ldi  temp, 26
	    mov DELAYREG1, temp
	    ldi  temp, 249
	    mov DELAYREG2, temp	    
	L1: dec  DELAYREG2
	    brne L1
	    dec  DELAYREG1
	    brne L1
	    nop
	ret

LONG_DELAY:
	; Generated by delay loop calculator
	; at http://www.bretmulvey.com/avrdelay.html
	;
	; Delay 20 000 cycles
	; 5ms at 4.0 MHz

	    ldi  temp, 104
	    mov DELAYREG1, temp
	    ldi  temp, 229
	    mov DELAYREG2, temp	    
	L2: dec  DELAYREG2
	    brne L2
	    dec  DELAYREG1
	    brne L2
	    nop
	ret

PUT_STRING:
	mov ZL,arg1 ; Load low part of byte address into ZL
	mov ZH,arg2 ; Load high part of byte address into ZH
	
	LOADBYTE:
		lpm ; Load byte from program memory into r0

		tst r0 ; Check if we've reached the end of the message
		breq END_LCD ; If so, quit

		mov arg1, r0
		rcall WRITE_TEXT
		adiw ZL,1 ; Increase Z registers
		rjmp LOADBYTE

	END_LCD:
		ret

WRITE_TEXT:
	mov temp, arg1 ; Put the character onto Port B
	sbi PORTA,1 ; SETB RS
	out PORTB, temp
	sbi PORTA,0 ; SETB EN
	cbi PORTA,0 ; CLR EN
	tst arg3	; If arg3 is not 0, delay
	brne DELAY
	ret

CLEAR_LCD:
	cbi PORTA,1 ; CLR RS
	ldi temp,$01 ; MOV DATA,0x01
	out PORTB,temp
	sbi PORTA,0 ; SETB EN
	cbi PORTA,0 ; CLR EN
	rcall DELAY
	ret

RESER_TIMER0:
	clr temp
	out TCNT0, temp
	ret

RESET_TIMER1:
	clr temp
	out TCNT1H, temp
	out TCNT1L, temp
	ret

ADD_LEVEL_TIME_NOW:

	push temp
	in temp,SREG
	push temp

	rcall RESET_TIMER1
	
	; add 1 to timer
	inc LEVELTIMENOW

	pop temp
	out SREG,temp
	pop temp

	reti

GET_NAME:

	ldi temp, 0x80
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY

	clr arg3
	ldi temp, high(2*message_input_nama)
	mov arg2, temp
	ldi temp, low(2*message_input_nama)
	mov arg1, temp
	rcall PUT_STRING

	ldi temp, 0xC0
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY

	; USE KEYPAD TO INPUT NAME
	ldi temp, 1
	mov arg1, temp
	rcall WAIT_KEY

	; GET VALUE IN TCNT0
	; USE VALUE AS SEED FOR RANDOM
	get_seed:
		in temp, TCNT0		; get value in timer for seed
		tst temp
		breq get_seed		; prevent seed=0
	mov SEED, temp

	ret

GET_RANDOM_NUMBER:

	; USING SEED, GENERATE NEXT RANDOM NUMBER
	; KOLABORASI DENGAN KELOMPOK SEAN ZELIQ

	ldi temp, 71
	mul SEED, temp
	mov SEED, r0
	ldi temp, 67
	adc SEED, temp

	mov temp, SEED		; PUT VALUE IN temp

	ret


SETUP_LAYOUT:

	ldi temp, low(layout_address)
	mov XL, temp ; Load low part of byte address into XL
	ldi temp, high(layout_address)
	mov XH, temp ; Load high part of byte address into XH
	
	rcall CLEAR_LCD
	; USING RANDOM GENERATOR, SETUP LAYOUT
	; GET RANDOM VALUE, AND IMMEDIATE 31
	rcall GET_RANDOM_NUMBER
	andi temp, 0x1F
	; nanti
	
	; CEK THAT LOCATION, IF ALREADY HAS NUMBER, ADD 1, AND IMMEDIATE 31
	; REPEAT 32 TIMES

	ldi temp, 0x80
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY

	clr arg3
	ldi temp, high(2*layout_coverall)
	mov arg2, temp
	ldi temp, low(2*layout_coverall)
	mov arg1, temp
	rcall PUT_STRING

	ldi temp, 0xC0
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY

	ldi temp, high(2*layout_coverall)
	mov arg2, temp
	ldi temp, low(2*layout_coverall)
	mov arg1, temp
	rcall PUT_STRING

	ldi temp, 0x80
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY	

	ret

FINISH_WRITING_NAME:

INCREASE_LETTER:

DECREASE_LETTER:

CHANGE_CHARACTER:
	cpi temp, 0x3E				; left
	breq MOVE_CURSOR_LEFT
	cpi temp, 0x5E				; down
	breq DECREASE_LETTER
	cpi temp, 0x6E				; right
	breq MOVE_CURSOR_RIGHT
	cpi temp, 0x5D				; up
	breq INCREASE_LETTER
	cpi temp, 0x6D				; enter
	breq FINISH_WRITING_NAME

	rjmp WAIT_KEY

CHANGE_CURSOR_FINALLY:
	mov temp, lokasicursor
	cbi PORTA,1 			; CLR RS
	cbi PORTA,2 			; CLR RW
	out PORTB, temp
	sbi PORTA,0 			; SETB EN
	cbi PORTA,0 			; CLR EN
	rcall LONG_DELAY
	ret

MOVE_CURSOR_LEFT:
	mov temp, lokasicursor
	andi temp, 0x0F
	tst temp
	brne NOWRAP				; Wrap to right side
		ldi temp, 0x0F
		or lokasicursor, temp
		rjmp MOVE_CURSOR_LEFT_FINALLY
	NOWRAP:
		mov temp, lokasicursor	; Dont wrap
		dec temp
		andi temp, 0xCF
		mov lokasicursor, temp
	MOVE_CURSOR_LEFT_FINALLY:
	rcall CHANGE_CURSOR_FINALLY		; Change the position of the cursor
	rjmp WAIT_KEY

MOVE_CURSOR_UP_DOWN:
	ldi temp, 0b01000000
	eor lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY		; Change the position of the cursor
	rjmp WAIT_KEY

MOVE_CURSOR_RIGHT:
	mov temp, lokasicursor
	inc temp
	andi temp, 0xCF			; Add 1, andi 0xCF to get important bits
	mov lokasicursor, temp
	rcall CHANGE_CURSOR_FINALLY		; Change the position of the cursor
	rjmp WAIT_KEY

OPEN_CARD:

	; DAPAT DIBUKA ? BUKA, COUNTER KARTU YANG TERBUKA +1 : RETURN DARI FUNGSI
	; YANG DIBUKA SUDAH 2 ? CEK KALO SAMA, COUNTER +1, BUKA SELAMANYA : TUTUP KEDUANYA

CLOSE_CARD:

	; GANTI SPRITE JADI BLACK BOX
	; COUNTER KARTU YANG TERBUKA -1

CHANGE_CURSOR:
	cpi temp, 0x3E				; left
	breq MOVE_CURSOR_LEFT
	cpi temp, 0x5E				; down
	breq MOVE_CURSOR_UP_DOWN
	cpi temp, 0x6E				; right
	breq MOVE_CURSOR_RIGHT
	cpi temp, 0x5D				; up
	breq MOVE_CURSOR_UP_DOWN
	cpi temp, 0x6D				; enter
	breq OPEN_CARD

	rjmp WAIT_KEY

GET_KEY:
	ldi temp,0b00110000
	mov col, temp
	ldi temp,0b00111111 ; rightmost column
	out PORTC,temp
	in temp,PINC 		
	ori temp,0b11110000 
	cpi temp,0b11111111 
	brne FOUND_KEY 		; key found

	ldi temp,0b01010000
	mov col, temp
	ldi temp,0b01011111 ; middle column
	out PORTC,temp
	in temp,PINC 		
	ori temp,0b11110000 
	cpi temp,0b11111111 
	brne FOUND_KEY 		; key found

	ldi temp,0b01100000
	mov col, temp
	ldi temp,0b01101111 ; leftmost column
	out PORTC,temp
	in temp,PINC 		
	ori temp,0b11110000 
	cpi temp,0b11111111 
	brne FOUND_KEY 		; key found


	FOUND_KEY:			; col (cat) row = button number
		mov temp, col
		or temp, row
	
	tst arg1
	breq CHANGE_CURSOR
	rjmp CHANGE_CHARACTER

WAIT_KEY:
	ldi temp,0b00001111 ; PB4..PB6=Null, pull-Up-resistors to input lines
	out PORTC,temp    ; of port pins PB0..PB3
	in temp,PINC     ; read key results
	mov row, temp		; value in temp is current row
	ori temp,0b11110000 ; mask all upper bits with a one
	cpi temp,0b11111111 ; all bits = One?
	brne GET_KEY         ; yes, no key is pressed
	rjmp WAIT_KEY

MAIN:
	
	; INPUT NAME FUNC, GET_NAME
	rcall GET_NAME

	; SAVE NAME IN FLASH MEMORY
	; NAME HAS MAX OF 8 BYTES

	ldi temp, 1
	mov arg3, temp
	ldi temp, high(2*message_start)
	mov arg2, temp
	ldi temp, low(2*message_start)
	mov arg1, temp
	rcall PUT_STRING

	; DELAY, GET READY TO START GAME
	; PREPARE LAYOUT
	rcall SETUP_LAYOUT
	; PREPARE TIMER

	clr arg1
	rjmp WAIT_KEY

	; LAYOUT DISIMPAN DI SRAM
	; COUNTER UNTUK KETAHUI JIKA PASANGAN TELAH DITEMUKAN
	; COUNTER == 16 ? UDAH SELESAI
	; LEVELTIMENOW == LEVELTIME ? KALAH
	; TAMBAHKAN 1 KE GLOBAL LEVEL COUNTER
	; START NEXT LEVEL, LEVELTIME -1

	; JIKA HABIS WAKTU, GAME BERAKHIR
	; SCORE > HIGHSCORE ? HIGHSCORE = SCORE
	; TAMPILKAN NAMA DAN HIGHSCORE

	; ADA BUTTON UNTUK MAIN ULANG
	; DITEKAN ? DELAY, RJMP INIT

	ldi temp, high(2*message_start)
	mov arg2, temp
	ldi temp, low(2*message_start)
	mov arg1, temp
	rcall PUT_STRING

	forever:
		rjmp forever

message_start:
.db "SIAP SIAP...", 0, 0

message_habis_waktu:
.db "WAKTU HABIS!", 0, 0

message_level_selesai:
.db "MANTAP!", 0

layout_coverall:
.db "????????????????", 0, 0

message_input_nama:
.db "INPUT NAMA:", 0

nama:
.db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

highscore:
.db 0, 0